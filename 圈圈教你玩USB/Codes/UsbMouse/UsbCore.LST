C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USBCORE
OBJECT MODULE PLACED IN UsbCore.OBJ
COMPILER INVOKED BY: D:\Keil-C51\C51\BIN\C51.EXE UsbCore.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\keil 5\C51\INC\Atmel) DEBU
                    -G OBJECTEXTEND

line level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3                                  
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UsbCore.c file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.29
  14          修改日期: 2008.07.10
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include "config.h"
  22          #include "pdiusbd12.h"
  23          #include "uart.h"
  24          #include "usbcore.h"
  25          
  26          idata uint8 Buffer[16];  //读端点0用的缓冲区
  27          
  28          //USB设备请求的各字段
  29          uint8  bmRequestType;
  30          uint8  bRequest;
  31          uint16 wValue;
  32          uint16 wIndex;
  33          uint16 wLength;
  34          
  35          //当前发送数据的位置
  36          uint8 *pSendData;
  37          //需要发送数据的长度
  38          uint16 SendLength;
  39          //是否需要发送0数据包的标志。在USB控制传输的数据过程中，
  40          //当返回的数据包字节数少于最大包长时，会认为数据过程结束。
  41          //当请求的字节数比实际需要返回的字节数长，而实际返回的字节
  42          //数又刚好是端点0大小的整数倍时，就需要返回一个0长度的数据包
  43          //来结束数据过程。因此这里增加一个标志，供程序决定是否需要返回
  44          //一个0长度的数据包。
  45          uint8 NeedZeroPacket;
  46          
  47          //当前的配置值。只有在设置非0配置后
  48          uint8 ConfigValue;
  49          
  50          //端点1缓冲是否忙的标志。当缓冲区中有数据时，该标志为真。
  51          //当缓冲区中空闲时，该标志为假。
  52          uint8 Ep1InIsBusy;
  53          
  54          //USB设备描述符的定义
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 2   

  55          code uint8 DeviceDescriptor[0x12]=  //设备描述符为18字节
  56          {
  57          //bLength字段。设备描述符的长度为18(0x12)字节
  58           0x12,
  59           
  60          //bDescriptorType字段。设备描述符的编号为0x01
  61           0x01,
  62           
  63          //bcdUSB字段。这里设置版本为USB1.1，即0x0110。
  64          //由于是小端结构，所以低字节在先，即0x10，0x01。
  65           0x10,
  66           0x01,
  67           
  68          //bDeviceClass字段。我们不在设备描述符中定义设备类，
  69          //而在接口描述符中定义设备类，所以该字段的值为0。
  70           0x00,
  71           
  72          //bDeviceSubClass字段。bDeviceClass字段为0时，该字段也为0。
  73           0x00,
  74           
  75          //bDeviceProtocol字段。bDeviceClass字段为0时，该字段也为0。
  76           0x00,
  77           
  78          //bMaxPacketSize0字段。PDIUSBD12的端点0大小的16字节。
  79           0x10,
  80           
  81          //idVender字段。厂商ID号，我们这里取0x8888，仅供实验用。
  82          //实际产品不能随便使用厂商ID号，必须跟USB协会申请厂商ID号。
  83          //注意小端模式，低字节在先。
  84           0x88,
  85           0x88,
  86           
  87          //idProduct字段。产品ID号，由于是第一个实验，我们这里取0x0001。
  88          //注意小端模式，低字节应该在前。
  89           0x01,
  90           0x00,
  91           
  92          //bcdDevice字段。我们这个USB鼠标刚开始做，就叫它1.0版吧，即0x0100。
  93          //小端模式，低字节在先。
  94           0x00,
  95           0x01,
  96           
  97          //iManufacturer字段。厂商字符串的索引值，为了方便记忆和管理，
  98          //字符串索引就从1开始吧。
  99           0x01,
 100          
 101          //iProduct字段。产品字符串的索引值。刚刚用了1，这里就取2吧。
 102          //注意字符串索引值不要使用相同的值。
 103           0x02,
 104           
 105          //iSerialNumber字段。设备的序列号字符串索引值。
 106          //这里取3就可以了。
 107           0x03,
 108          
 109          //bNumConfigurations字段。该设备所具有的配置数。
 110          //我们只需要一种配置就行了，因此该值设置为1。
 111           0x01
 112          };
 113          //////////////////////////设备描述符完毕//////////////////////////////
 114          
 115          //USB报告描述符的定义
 116          code uint8 ReportDescriptor[]=
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 3   

 117          {
 118           //每行开始的第一字节为该条目的前缀，前缀的格式为：
 119           //D7~D4：bTag。D3~D2：bType；D1~D0：bSize。以下分别对每个条目注释。
 120           
 121           //这是一个全局（bType为1）条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 122           //后面跟一字节数据（bSize为1），后面的字节数就不注释了，
 123           //自己根据bSize来判断。
 124           0x05, 0x01, // USAGE_PAGE (Generic Desktop)
 125           
 126           //这是一个局部（bType为2）条目，说明接下来的应用集合用途用于鼠标
 127           0x09, 0x02, // USAGE (Mouse)
 128           
 129           //这是一个主条目（bType为0）条目，开集合，后面跟的数据0x01表示
 130           //该集合是一个应用集合。它的性质在前面由用途页和用途定义为
 131           //普通桌面用的鼠标。
 132           0xa1, 0x01, // COLLECTION (Application)
 133           
 134           //这是一个局部条目。说明用途为指针集合
 135           0x09, 0x01, //   USAGE (Pointer)
 136           
 137           //这是一个主条目，开集合，后面跟的数据0x00表示该集合是一个
 138           //物理集合，用途由前面的局部条目定义为指针集合。
 139           0xa1, 0x00, //   COLLECTION (Physical)
 140           
 141           //这是一个全局条目，选择用途页为按键（Button Page(0x09)）
 142           0x05, 0x09, //     USAGE_PAGE (Button)
 143           
 144           //这是一个局部条目，说明用途的最小值为1。实际上是鼠标左键。
 145           0x19, 0x01, //     USAGE_MINIMUM (Button 1)
 146           
 147           //这是一个局部条目，说明用途的最大值为3。实际上是鼠标中键。
 148           0x29, 0x03, //     USAGE_MAXIMUM (Button 3)
 149           
 150           //这是一个全局条目，说明返回的数据的逻辑值（就是我们返回的数据域的值啦）
 151           //最小为0。因为我们这里用Bit来表示一个数据域，因此最小为0，最大为1。
 152           0x15, 0x00, //     LOGICAL_MINIMUM (0)
 153           
 154           //这是一个全局条目，说明逻辑值最大为1。
 155           0x25, 0x01, //     LOGICAL_MAXIMUM (1)
 156           
 157           //这是一个全局条目，说明数据域的数量为三个。
 158           0x95, 0x03, //     REPORT_COUNT (3)
 159           
 160           //这是一个全局条目，说明每个数据域的长度为1个bit。
 161           0x75, 0x01, //     REPORT_SIZE (1)
 162           
 163           //这是一个主条目，说明有3个长度为1bit的数据域（数量和长度
 164           //由前面的两个全局条目所定义）用来做为输入，
 165           //属性为：Data,Var,Abs。Data表示这些数据可以变动，Var表示
 166           //这些数据域是独立的，每个域表示一个意思。Abs表示绝对值。
 167           //这样定义的结果就是，第一个数据域bit0表示按键1（左键）是否按下，
 168           //第二个数据域bit1表示按键2（右键）是否按下，第三个数据域bit2表示
 169           //按键3（中键）是否按下。
 170           0x81, 0x02, //     INPUT (Data,Var,Abs)
 171           
 172           //这是一个全局条目，说明数据域数量为1个
 173           0x95, 0x01, //     REPORT_COUNT (1)
 174           
 175           //这是一个全局条目，说明每个数据域的长度为5bit。
 176           0x75, 0x05, //     REPORT_SIZE (5)
 177           
 178           //这是一个主条目，输入用，由前面两个全局条目可知，长度为5bit，
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 4   

 179           //数量为1个。它的属性为常量（即返回的数据一直是0）。
 180           //这个只是为了凑齐一个字节（前面用了3个bit）而填充的一些数据
 181           //而已，所以它是没有实际用途的。
 182           0x81, 0x03, //     INPUT (Cnst,Var,Abs)
 183           
 184           //这是一个全局条目，选择用途页为普通桌面Generic Desktop Page(0x01)
 185           0x05, 0x01, //     USAGE_PAGE (Generic Desktop)
 186           
 187           //这是一个局部条目，说明用途为X轴
 188           0x09, 0x30, //     USAGE (X)
 189           
 190           //这是一个局部条目，说明用途为Y轴
 191           0x09, 0x31, //     USAGE (Y)
 192           
 193           //这是一个局部条目，说明用途为滚轮
 194           0x09, 0x38, //     USAGE (Wheel)
 195           
 196           //下面两个为全局条目，说明返回的逻辑最小和最大值。
 197           //因为鼠标指针移动时，通常是用相对值来表示的，
 198           //相对值的意思就是，当指针移动时，只发送移动量。
 199           //往右移动时，X值为正；往下移动时，Y值为正。
 200           //对于滚轮，当滚轮往上滚时，值为正。
 201           0x15, 0x81, //     LOGICAL_MINIMUM (-127)
 202           0x25, 0x7f, //     LOGICAL_MAXIMUM (127)
 203           
 204           //这是一个全局条目，说明数据域的长度为8bit。
 205           0x75, 0x08, //     REPORT_SIZE (8)
 206           
 207           //这是一个全局条目，说明数据域的个数为3个。
 208           0x95, 0x03, //     REPORT_COUNT (3)
 209           
 210           //这是一个主条目。它说明这三个8bit的数据域是输入用的，
 211           //属性为：Data,Var,Rel。Data说明数据是可以变的，Var说明
 212           //这些数据域是独立的，即第一个8bit表示X轴，第二个8bit表示
 213           //Y轴，第三个8bit表示滚轮。Rel表示这些值是相对值。
 214           0x81, 0x06, //     INPUT (Data,Var,Rel)
 215           
 216           //下面这两个主条目用来关闭前面的集合用。
 217           //我们开了两个集合，所以要关两次。bSize为0，所以后面没数据。
 218           0xc0,       //   END_COLLECTION
 219           0xc0        // END_COLLECTION
 220          };
 221          //通过上面的报告描述符的定义，我们知道返回的输入报告具有4字节。
 222          //第一字节的低3位用来表示按键是否按下的，高5位为常数0，无用。
 223          //第二字节表示X轴改的变量，第三字节表示Y轴的改变量，第四字节表示
 224          //滚轮的改变量。我们在中断端点1中应该要按照上面的格式返回实际的
 225          //鼠标数据。
 226          ///////////////////////////报告描述符完毕////////////////////////////
 227          
 228          //USB配置描述符集合的定义
 229          //配置描述符总长度为9+9+9+7字节
 230          code uint8 ConfigurationDescriptor[9+9+9+7]=
 231          {
 232           /***************配置描述符***********************/
 233           //bLength字段。配置描述符的长度为9字节。
 234           0x09,
 235           
 236           //bDescriptorType字段。配置描述符编号为0x02。
 237           0x02,
 238           
 239           //wTotalLength字段。配置描述符集合的总长度，
 240           //包括配置描述符本身、接口描述符、类描述符、端点描述符等。
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 5   

 241           sizeof(ConfigurationDescriptor)&0xFF, //低字节
 242           (sizeof(ConfigurationDescriptor)>>8)&0xFF, //高字节
 243           
 244           //bNumInterfaces字段。该配置包含的接口数，只有一个接口。
 245           0x01,
 246           
 247           //bConfiguration字段。该配置的值为1。
 248           0x01,
 249           
 250           //iConfigurationz字段，该配置的字符串索引。这里没有，为0。
 251           0x00,
 252           
 253           //bmAttributes字段，该设备的属性。由于我们的板子是总线供电的，
 254           //并且我们不想实现远程唤醒的功能，所以该字段的值为0x80。
 255           0x80,
 256           
 257           //bMaxPower字段，该设备需要的最大电流量。由于我们的板子
 258           //需要的电流不到100mA，因此我们这里设置为100mA。由于每单位
 259           //电流为2mA，所以这里设置为50(0x32)。
 260           0x32,
 261           
 262           /*******************接口描述符*********************/
 263           //bLength字段。接口描述符的长度为9字节。
 264           0x09,
 265           
 266           //bDescriptorType字段。接口描述符的编号为0x04。
 267           0x04,
 268           
 269           //bInterfaceNumber字段。该接口的编号，第一个接口，编号为0。
 270           0x00,
 271           
 272           //bAlternateSetting字段。该接口的备用编号，为0。
 273           0x00,
 274           
 275           //bNumEndpoints字段。非0端点的数目。由于USB鼠标只需要一个
 276           //中断输入端点，因此该值为1。
 277           0x01,
 278           
 279           //bInterfaceClass字段。该接口所使用的类。USB鼠标是HID类，
 280           //HID类的编码为0x03。
 281           0x03,
 282           
 283           //bInterfaceSubClass字段。该接口所使用的子类。在HID1.1协议中，
 284           //只规定了一种子类：支持BIOS引导启动的子类。
 285           //USB键盘、鼠标属于该子类，子类代码为0x01。
 286           0x01,
 287           
 288           //bInterfaceProtocol字段。如果子类为支持引导启动的子类，
 289           //则协议可选择鼠标和键盘。键盘代码为0x01，鼠标代码为0x02。
 290           0x02,
 291           
 292           //iConfiguration字段。该接口的字符串索引值。这里没有，为0。
 293           0x00,
 294           
 295           /******************HID描述符************************/
 296           //bLength字段。本HID描述符下只有一个下级描述符。所以长度为9字节。
 297           0x09,
 298           
 299           //bDescriptorType字段。HID描述符的编号为0x21。
 300           0x21,
 301           
 302           //bcdHID字段。本协议使用的HID1.1协议。注意低字节在先。
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 6   

 303           0x10,
 304           0x01,
 305           
 306           //bCountyCode字段。设备适用的国家代码，这里选择为美国，代码0x21。
 307           0x21,
 308           
 309           //bNumDescriptors字段。下级描述符的数目。我们只有一个报告描述符。
 310           0x01,
 311           
 312           //bDescritporType字段。下级描述符的类型，为报告描述符，编号为0x22。
 313           0x22,
 314           
 315           //bDescriptorLength字段。下级描述符的长度。下级描述符为报告描述符。
 316           sizeof(ReportDescriptor)&0xFF,
 317           (sizeof(ReportDescriptor)>>8)&0xFF,
 318           
 319           /**********************端点描述符***********************/
 320           //bLength字段。端点描述符长度为7字节。
 321           0x07,
 322           
 323           //bDescriptorType字段。端点描述符编号为0x05。
 324           0x05,
 325           
 326           //bEndpointAddress字段。端点的地址。我们使用D12的输入端点1。
 327           //D7位表示数据方向，输入端点D7为1。所以输入端点1的地址为0x81。
 328           0x81,
 329           
 330           //bmAttributes字段。D1~D0为端点传输类型选择。
 331           //该端点为中断端点。中断端点的编号为3。其它位保留为0。
 332           0x03,
 333           
 334           //wMaxPacketSize字段。该端点的最大包长。端点1的最大包长为16字节。
 335           //注意低字节在先。
 336           0x10,
 337           0x00,
 338           
 339           //bInterval字段。端点查询的时间，我们设置为10个帧时间，即10ms。
 340           0x0A
 341          };
 342          ////////////////////////配置描述符集合完毕//////////////////////////
 343          
 344          /************************语言ID的定义********************/
 345          code uint8 LanguageId[4]=
 346          {
 347           0x04, //本描述符的长度
 348           0x03, //字符串描述符
 349           //0x0409为美式英语的ID
 350           0x09,
 351           0x04
 352          };
 353          ////////////////////////语言ID完毕//////////////////////////////////
 354          
 355          /**************************************************/
 356          /*********        本转换结果来自         **********/
 357          /********* Http://computer00.21ic.org    **********/
 358          /*********        作者: 电脑圈圈         **********/
 359          /*********         欢迎大家使用          **********/
 360          /*********    版权所有，盗版请写明出处   **********/
 361          /**************************************************/
 362          
 363          //http://computer00.21ic.org/user1/2198/archives/2007/42769.html
 364          //字符串“电脑圈圈的USB专区 Http://group.ednchina.com/93/”的Unicode编码
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 7   

 365          //8位小端格式
 366          code uint8 ManufacturerStringDescriptor[82]={
 367          82,         //该描述符的长度为82字节
 368          0x03,       //字符串描述符的类型编码为0x03
 369          0x35, 0x75, //电
 370          0x11, 0x81, //脑
 371          0x08, 0x57, //圈
 372          0x08, 0x57, //圈
 373          0x84, 0x76, //的
 374          0x55, 0x00, //U
 375          0x53, 0x00, //S
 376          0x42, 0x00, //B
 377          0x13, 0x4e, //专
 378          0x3a, 0x53, //区
 379          0x20, 0x00, // 
 380          0x48, 0x00, //H
 381          0x74, 0x00, //t
 382          0x74, 0x00, //t
 383          0x70, 0x00, //p
 384          0x3a, 0x00, //:
 385          0x2f, 0x00, ///
 386          0x2f, 0x00, ///
 387          0x67, 0x00, //g
 388          0x72, 0x00, //r
 389          0x6f, 0x00, //o
 390          0x75, 0x00, //u
 391          0x70, 0x00, //p
 392          0x2e, 0x00, //.
 393          0x65, 0x00, //e
 394          0x64, 0x00, //d
 395          0x6e, 0x00, //n
 396          0x63, 0x00, //c
 397          0x68, 0x00, //h
 398          0x69, 0x00, //i
 399          0x6e, 0x00, //n
 400          0x61, 0x00, //a
 401          0x2e, 0x00, //.
 402          0x63, 0x00, //c
 403          0x6f, 0x00, //o
 404          0x6d, 0x00, //m
 405          0x2f, 0x00, ///
 406          0x39, 0x00, //9
 407          0x33, 0x00, //3
 408          0x2f, 0x00  ///
 409          };
 410          /////////////////////////厂商字符串结束/////////////////////////////
 411          
 412          //字符串“《圈圈教你玩USB》之USB鼠标”的Unicode编码
 413          //8位小端格式
 414          code uint8 ProductStringDescriptor[34]={
 415          34,         //该描述符的长度为34字节
 416          0x03,       //字符串描述符的类型编码为0x03
 417          0x0a, 0x30, //《
 418          0x08, 0x57, //圈
 419          0x08, 0x57, //圈
 420          0x59, 0x65, //教
 421          0x60, 0x4f, //你
 422          0xa9, 0x73, //玩
 423          0x55, 0x00, //U
 424          0x53, 0x00, //S
 425          0x42, 0x00, //B
 426          0x0b, 0x30, //》
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 8   

 427          0x4b, 0x4e, //之
 428          0x55, 0x00, //U
 429          0x53, 0x00, //S
 430          0x42, 0x00, //B
 431          0x20, 0x9f, //鼠
 432          0x07, 0x68  //标
 433          };
 434          ////////////////////////产品字符串结束////////////////////////////
 435          
 436          //字符串“2008-07-07”的Unicode编码
 437          //8位小端格式
 438          code uint8 SerialNumberStringDescriptor[22]={
 439          22,         //该描述符的长度为22字节
 440          0x03,       //字符串描述符的类型编码为0x03
 441          0x32, 0x00, //2
 442          0x30, 0x00, //0
 443          0x30, 0x00, //0
 444          0x38, 0x00, //8
 445          0x2d, 0x00, //-
 446          0x30, 0x00, //0
 447          0x37, 0x00, //7
 448          0x2d, 0x00, //-
 449          0x30, 0x00, //0
 450          0x37, 0x00  //7
 451          };
 452          //////////////////////产品序列号字符串结束/////////////////////////
 453          
 454          /********************************************************************
 455          函数功能：延时x毫秒函数。
 456          入口参数：x：延时的毫秒数。
 457          返    回：无。
 458          备    注：无。
 459          ********************************************************************/
 460          void DelayXms(uint16 x)                
 461          {
 462   1       uint16 i;
 463   1       uint16 j;
 464   1       for(i=0;i<x;i++)
 465   1       for(j=0;j<227;j++); //循环语句延时
 466   1      }
 467          ////////////////////////End of function//////////////////////////////
 468          
 469          /********************************************************************
 470          函数功能：USB断开连接函数。
 471          入口参数：无。
 472          返    回：无。
 473          备    注：无。
 474          ********************************************************************/
 475          void UsbDisconnect(void)
 476          {
 477   1      #ifdef DEBUG0
 478   1       Prints("断开USB连接。\r\n");
 479   1      #endif
 480   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 481   1       D12WriteByte(0x06); //设置模式的第一字节
 482   1       D12WriteByte(0x47); //设置模式的第二字节
 483   1       DelayXms(1000);  //延迟1秒
 484   1      }
 485          ////////////////////////End of function//////////////////////////////
 486          
 487          /********************************************************************
 488          函数功能：USB连接函数。
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 9   

 489          入口参数：无。
 490          返    回：无。
 491          备    注：无。
 492          ********************************************************************/
 493          void UsbConnect(void)
 494          {
 495   1      #ifdef DEBUG0
 496   1       Prints("连接USB。\r\n");
 497   1      #endif
 498   1       D12WriteCommand(D12_SET_MODE);  //写设置模式命令
 499   1       D12WriteByte(0x16); //设置模式的第一字节
 500   1       D12WriteByte(0x47); //设置模式的第二字节
 501   1      }
 502          ////////////////////////End of function//////////////////////////////
 503          
 504          /********************************************************************
 505          函数功能：总线挂起中断处理函数。
 506          入口参数：无。
 507          返    回：无。
 508          备    注：无。
 509          ********************************************************************/
 510          void UsbBusSuspend(void)
 511          {
 512   1      #ifdef DEBUG0
 513   1       Prints("USB总线挂起。\r\n");
 514   1      #endif
 515   1      }
 516          ////////////////////////End of function//////////////////////////////
 517          
 518          /********************************************************************
 519          函数功能：总线复位中断处理函数。
 520          入口参数：无。
 521          返    回：无。
 522          备    注：无。
 523          ********************************************************************/
 524          void UsbBusReset(void)
 525          {
 526   1      #ifdef DEBUG0
 527   1       Prints("USB总线复位。\r\n");
 528   1      #endif
 529   1       Ep1InIsBusy=0; //复位后端点1输入缓冲区空闲。
 530   1      }
 531          ////////////////////////End of function//////////////////////////////
 532          
 533          /********************************************************************
 534          函数功能：根据pData和SendLength将数据发送到端点0的函数。
 535          入口参数：无。
 536          返    回：无。
 537          备    注：无。
 538          ********************************************************************/
 539          void UsbEp0SendData(void)
 540          {
 541   1       //将数据写到端点中去准备发送
 542   1       //写之前要先判断一下需要发送的数据是否比端点0
 543   1       //最大长度大，如果超过端点大小，则一次只能发送
 544   1       //最大包长的数据。端点0的最大包长在DeviceDescriptor[7]
 545   1       if(SendLength>DeviceDescriptor[7])
 546   1       {
 547   2        //按最大包长度发送
 548   2        D12WriteEndpointBuffer(USB_ENDPOINT0_IN,DeviceDescriptor[7],pSendData);
 549   2        //发送后剩余字节数减少最大包长
 550   2        SendLength-=DeviceDescriptor[7];
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 10  

 551   2        //发送一次后指针位置要调整
 552   2        pSendData+= DeviceDescriptor[7];
 553   2       }
 554   1       else
 555   1       {
 556   2        if(SendLength!=0)
 557   2        {
 558   3         //不够最大包长，可以直接发送
 559   3         D12WriteEndpointBuffer(USB_ENDPOINT0_IN,SendLength,pSendData);
 560   3         //发送完毕后，SendLength长度变为0
 561   3         SendLength=0;
 562   3        }
 563   2        else //如果要发送的数据包长度为0
 564   2        {
 565   3         if(NeedZeroPacket==1) //如果需要发送0长度数据
 566   3         {
 567   4          D12WriteEndpointBuffer(USB_ENDPOINT0_IN,0,pSendData); //发送0长度数据包
 568   4          NeedZeroPacket=0; //清需要发送0长度数据包标志
 569   4         }
 570   3        }
 571   2       }
 572   1      }
 573          ////////////////////////End of function//////////////////////////////
 574          
 575          /********************************************************************
 576          函数功能：端点0输出中断处理函数。
 577          入口参数：无。
 578          返    回：无。
 579          备    注：无。
 580          ********************************************************************/
 581          void UsbEp0Out(void)
 582          {
 583   1      #ifdef DEBUG0
 584   1              Prints("USB端点0输出中断。\r\n");
 585   1      #endif
 586   1              
 587   1               //读取端点0输出最后传输状态，该操作清除中断标志
 588   1               //并判断第5位是否为1，如果是，则说明是建立包
 589   1              if(D12ReadEndpointLastStatus(USB_ENDPOINT0_OUT) & 0x20) // setup 
 590   1              {
 591   2                      D12ReadEndpointBuffer(USB_ENDPOINT0_OUT, 16, Buffer); //读建立过程数据
 592   2                      D12AcknowledgeSetup(); //应答建立包
 593   2                      D12ClearBuffer(); //清 USB 接口芯片的缓冲区
 594   2                      
 595   2                      //将缓冲数据填到设备请求的各字段中
 596   2                      bmRequestType = Buffer[0];
 597   2                      bRequest = Buffer[1];
 598   2                      wValue = Buffer[2]+(((uint16)Buffer[3])<<8);
 599   2                      wIndex = Buffer[4]+(((uint16)Buffer[5])<<8);
 600   2                      wLength = Buffer[6]+(((uint16)Buffer[7])<<8);
 601   2                      
 602   2                      //下面的代码判断具体的请求，并根据不同的请求进行相关操作
 603   2                      //如果D7位为1，则说明是输入请求
 604   2                      if((bmRequestType&0x80)==0x80)
 605   2                      {
 606   3                              //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 607   3                              //0为标准请求，1为类请求，2为厂商请求。
 608   3                              switch((bmRequestType>>5)&0x03)
 609   3                              {
 610   4                              case 0:  //标准请求
 611   4                                      #ifdef DEBUG0
 612   4                                      Prints("USB标准输入请求：");
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 11  

 613   4                                      #endif
 614   4                                      //USB协议定义了几个标准输入请求，我们实现这些标准请求即可
 615   4                                      //请求的代码在bRequest中，对不同的请求代码进行散转
 616   4                                      //事实上，我们还需要对接收者进行散转，因为不同的请求接收者
 617   4                                      //是不一样的。接收者在bmRequestType的D4~D0位中定义。
 618   4                                      //我们这里为了简化操作，有些就省略了对接收者的判断。
 619   4                                      //例如获取描述符的请求，只根据描述符的类型来区别。
 620   4                                      switch(bRequest) // 不同请求类型
 621   4                                      {
 622   5                                      case GET_CONFIGURATION: //获取配置
 623   5                                              #ifdef DEBUG0
 624   5                                              Prints("获取配置。\r\n");
 625   5                                              #endif
 626   5                                      
 627   5                                              break;
 628   5      
 629   5                                      case GET_DESCRIPTOR:  //获取描述符
 630   5                                              #ifdef DEBUG0
 631   5                                              Prints("获取描述符――");
 632   5                                              #endif
 633   5                                              //对描述符类型进行散转，对于全速设备，
 634   5                                              //标准请求只支持发送到设备的设备、配置、字符串三种描述符
 635   5                                              switch((wValue>>8) & 0xFF)
 636   5                                              {
 637   6                                              case DEVICE_DESCRIPTOR: //设备描述符
 638   6                                                      #ifdef DEBUG0
 639   6                                                              Prints("设备描述符。\r\n");
 640   6                                                      #endif
 641   6                                                      pSendData=DeviceDescriptor;  //需要发送的数据
 642   6                                                      //判断请求的字节数是否比实际需要发送的字节数多
 643   6                                                      //这里请求的是设备描述符，因此数据长度就是
 644   6                                                      //DeviceDescriptor[0]。如果请求的比实际的长，
 645   6                                                      //那么只返回实际长度的数据
 646   6                                                      if(wLength>DeviceDescriptor[0])
 647   6                                                      {
 648   7                                                              SendLength=DeviceDescriptor[0];
 649   7                                                              if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 650   7                                                              {
 651   8                                                                      NeedZeroPacket=1; //需要返回0长度的数据包
 652   8                                                              }
 653   7                                                      }
 654   6                                                      else
 655   6                                                      {
 656   7                                                              SendLength=wLength;
 657   7                                                      }
 658   6                                                      //将数据通过EP0返回
 659   6                                                      UsbEp0SendData();
 660   6                                                      break;
 661   6                                               
 662   6                                              case CONFIGURATION_DESCRIPTOR:  //配置描述符
 663   6                                                      #ifdef DEBUG0
 664   6                                                              Prints("配置描述符。\r\n");
 665   6                                                      #endif
 666   6                                                      pSendData=ConfigurationDescriptor; //需要发送的数据为配置描述符
 667   6                                                      //判断请求的字节数是否比实际需要发送的字节数多
 668   6                                                      //这里请求的是配置描述符集合，因此数据长度就是
 669   6                                                      //ConfigurationDescriptor[3]*256+ConfigurationDescriptor[2]。
 670   6                                                      //如果请求的比实际的长，那么只返回实际长度的数据
 671   6                                                      SendLength=ConfigurationDescriptor[3];
 672   6                                                      SendLength=SendLength*256+ConfigurationDescriptor[2];
 673   6                                                      if(wLength>SendLength)
 674   6                                                      {
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 12  

 675   7                                                              if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 676   7                                                              {
 677   8                                                                      NeedZeroPacket=1; //需要返回0长度的数据包
 678   8                                                              }
 679   7                                                      }
 680   6                                                      else
 681   6                                                      {
 682   7                                                              SendLength=wLength;
 683   7                                                      }
 684   6                                                      //将数据通过EP0返回
 685   6                                                      UsbEp0SendData();
 686   6                                                      break;
 687   6                                               
 688   6                                              case STRING_DESCRIPTOR:  //字符串描述符
 689   6                                                      #ifdef DEBUG0
 690   6                                                              Prints("字符串描述符");
 691   6                                                      #endif
 692   6                                              
 693   6                                                      switch(wValue & 0xFF)  //根据wValue的低字节（索引值）散转
 694   6                                                      {
 695   7                                                      case 0:  //获取语言 ID
 696   7                                                              #ifdef DEBUG0
 697   7                                                                      Prints("(语言ID)。\r\n");
 698   7                                                              #endif
 699   7                                                              pSendData=LanguageId;
 700   7                                                              SendLength=LanguageId[0];
 701   7                                                              break;
 702   7                                                      
 703   7                                                      case 1:  //厂商字符串的索引值为1，所以这里为厂商字符串
 704   7                                                              #ifdef DEBUG0
 705   7                                                                      Prints("(厂商描述)。\r\n");
 706   7                                                              #endif
 707   7                                                              pSendData=ManufacturerStringDescriptor;
 708   7                                                              SendLength=ManufacturerStringDescriptor[0];
 709   7                                                              break;
 710   7                                                      
 711   7                                                      case 2:  //产品字符串的索引值为2，所以这里为产品字符串
 712   7                                                              #ifdef DEBUG0
 713   7                                                                      Prints("(产品描述)。\r\n");
 714   7                                                              #endif
 715   7                                                              pSendData=ProductStringDescriptor;
 716   7                                                              SendLength=ProductStringDescriptor[0];
 717   7                                                      break;
 718   7                                                      
 719   7                                                      case 3:  //产品序列号的索引值为3，所以这里为序列号
 720   7                                                              #ifdef DEBUG0
 721   7                                                                      Prints("(产品序列号)。\r\n");
 722   7                                                              #endif
 723   7                                                              pSendData=SerialNumberStringDescriptor;
 724   7                                                              SendLength=SerialNumberStringDescriptor[0];
 725   7                                                              break;
 726   7                                                      
 727   7                                                      default :
 728   7                                                              #ifdef DEBUG0
 729   7                                                                      Prints("(未知的索引值)。\r\n");
 730   7                                                              #endif
 731   7                                                              //对于未知索引值的请求，返回一个0长度的包
 732   7                                                              SendLength=0;
 733   7                                                              NeedZeroPacket=1;
 734   7                                                              break;
 735   7                                                      }
 736   6                                                      //判断请求的字节数是否比实际需要发送的字节数多
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 13  

 737   6                                                      //如果请求的比实际的长，那么只返回实际长度的数据
 738   6                                                      if(wLength > SendLength)
 739   6                                                      {
 740   7                                                              if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 741   7                                                              {
 742   8                                                                      NeedZeroPacket=1; //需要返回0长度的数据包
 743   8                                                              }
 744   7                                                      }
 745   6                                                      else
 746   6                                                      {
 747   7                                                              SendLength=wLength;
 748   7                                                      }
 749   6                                                      //将数据通过EP0返回
 750   6                                                      UsbEp0SendData();         
 751   6                                                      break;
 752   6      
 753   6                                              case REPORT_DESCRIPTOR:  //报告描述符
 754   6                                                      #ifdef DEBUG0
 755   6                                                              Prints("报告描述符。\r\n");
 756   6                                                      #endif
 757   6                                                      pSendData=ReportDescriptor; //需要发送的数据为报告描述符
 758   6                                                      SendLength=sizeof(ReportDescriptor); //需要返回的数据长度         
 759   6                                                      //判断请求的字节数是否比实际需要发送的字节数多
 760   6                                                      //如果请求的比实际的长，那么只返回实际长度的数据
 761   6                                                      if(wLength>SendLength)
 762   6                                                      {
 763   7                                                              if(SendLength%DeviceDescriptor[7]==0) //并且刚好是整数个数据包时
 764   7                                                              {
 765   8                                                                      NeedZeroPacket=1; //需要返回0长度的数据包
 766   8                                                              }
 767   7                                                      }
 768   6                                                      else
 769   6                                                      {
 770   7                                                              SendLength=wLength;
 771   7                                                      }
 772   6                                                      //将数据通过EP0返回
 773   6                                                      UsbEp0SendData();
 774   6                                                      break;
 775   6                                              
 776   6                                              default:  //其它描述符
 777   6                                                      #ifdef DEBUG0
 778   6                                                              Prints("其他描述符，描述符代码：");
 779   6                                                              PrintHex((wValue>>8)&0xFF);
 780   6                                                              Prints("\r\n");
 781   6                                                      #endif
 782   6                                                      break;
 783   6                                              }
 784   5                                              break;
 785   5      
 786   5                                      case GET_INTERFACE: //获取接口
 787   5                                              #ifdef DEBUG0
 788   5                                                      Prints("获取接口。\r\n");
 789   5                                              #endif
 790   5                                              break;
 791   5      
 792   5                                      case GET_STATUS: //获取状态
 793   5                                              #ifdef DEBUG0
 794   5                                                      Prints("获取状态。\r\n");
 795   5                                              #endif
 796   5                                              break;
 797   5      
 798   5                                      case SYNCH_FRAME: //同步帧
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 14  

 799   5                                              #ifdef DEBUG0
 800   5                                                      Prints("同步帧。\r\n");
 801   5                                              #endif
 802   5                                              break;
 803   5      
 804   5                                      default:  //未定义的标准请求
 805   5                                              #ifdef DEBUG0
 806   5                                                      Prints("错误：未定义的标准输入请求。\r\n");
 807   5                                              #endif       
 808   5                                              break;
 809   5                                      }
 810   4                                      break;
 811   4      
 812   4                              case 1:  //类请求
 813   4                                      #ifdef DEBUG0
 814   4                                              Prints("USB类输入请求：\r\n");
 815   4                                      #endif
 816   4                                      break;
 817   4          
 818   4                              case 2:  //厂商请求
 819   4                                      #ifdef DEBUG0
 820   4                                              Prints("USB厂商输入请求：\r\n");
 821   4                                      #endif
 822   4                                      break;
 823   4                              
 824   4                              default: //未定义的请求。这里只显示一个报错信息。
 825   4                                      #ifdef DEBUG0
 826   4                                              Prints("错误：未定义的输入请求。\r\n");
 827   4                                      #endif
 828   4                                      break;
 829   4                              }
 830   3                      }
 831   2                      //否则说明是输出请求
 832   2                      else //if(bmRequestType&0x80==0x80)之else
 833   2                      {
 834   3                              //根据bmRequestType的D6~5位散转，D6~5位表示请求的类型
 835   3                              //0为标准请求，1为类请求，2为厂商请求。
 836   3                              switch((bmRequestType>>5) & 0x03)
 837   3                              {
 838   4                              case 0:  //标准请求
 839   4                                      #ifdef DEBUG0
 840   4                                              Prints("USB标准输出请求：");
 841   4                                      #endif
 842   4                                      //USB协议定义了几个标准输出请求，我们实现这些标准请求即可
 843   4                                      //请求的代码在bRequest中，对不同的请求代码进行散转
 844   4                                      switch(bRequest)
 845   4                                      {
 846   5                                      case CLEAR_FEATURE:  //清除特性
 847   5                                              #ifdef DEBUG0
 848   5                                                      Prints("清除特性。\r\n");
 849   5                                              #endif
 850   5                                      break;
 851   5            
 852   5                                      case SET_ADDRESS:  //设置地址
 853   5                                              #ifdef DEBUG0
 854   5                                                      Prints("设置地址。地址为：");
 855   5                                                      PrintHex(wValue&0xFF); //显示所设置的地址
 856   5                                                      Prints("\r\n");
 857   5                                              #endif
 858   5                                              D12SetAddress(wValue&0xFF); //wValue中的低字节是设置的地址值
 859   5                                              //设置地址没有数据过程，直接进入到状态过程，返回一个0长度的数据包
 860   5                                              SendLength = 0;
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 15  

 861   5                                              NeedZeroPacket = 1;
 862   5                                              //将数据通过EP0返回
 863   5                                              UsbEp0SendData();
 864   5                                              break;
 865   5            
 866   5                                      case SET_CONFIGURATION: //设置配置
 867   5                                              #ifdef DEBUG0
 868   5                                                      Prints("设置配置。\r\n");
 869   5                                              #endif
 870   5                                              //使能非0端点。非0端点只有在设置为非0的配置后才能使能。
 871   5                                              //wValue的低字节为配置的值，如果该值为非0，才能使能非0端点。
 872   5                                              //保存当前配置值
 873   5                                              ConfigValue=wValue&0xFF; //
 874   5                                              D12SetEndpointEnable(ConfigValue);
 875   5                                              //返回一个0长度的状态数据包
 876   5                                              SendLength=0;
 877   5                                              NeedZeroPacket=1;
 878   5                                              //将数据通过EP0返回
 879   5                                              UsbEp0SendData();
 880   5                                              break;
 881   5      
 882   5                                      case SET_DESCRIPTOR: //设置描述符
 883   5                                              #ifdef DEBUG0
 884   5                                                      Prints("设置描述符。\r\n");
 885   5                                              #endif
 886   5                                              break;
 887   5            
 888   5                                      case SET_FEATURE: //设置特性
 889   5                                              #ifdef DEBUG0
 890   5                                                      Prints("设置特性。\r\n");
 891   5                                              #endif
 892   5                                              break;
 893   5      
 894   5                                      case SET_INTERFACE: //设置接口
 895   5                                              #ifdef DEBUG0
 896   5                                                      Prints("设置接口。\r\n");
 897   5                                              #endif
 898   5                                              break;      
 899   5            
 900   5                                      default:  //未定义的标准请求
 901   5                                              #ifdef DEBUG0
 902   5                                                      Prints("错误：未定义的标准输出请求。\r\n");
 903   5                                              #endif       
 904   5                                              break;
 905   5                                      }
 906   4                                      break;
 907   4          
 908   4                              case 1:  //类请求
 909   4                                      #ifdef DEBUG0
 910   4                                              Prints("USB类输出请求：");
 911   4                                      #endif
 912   4                                      switch(bRequest)
 913   4                                      {
 914   5                                      case SET_IDLE:
 915   5                                              #ifdef DEBUG0
 916   5                                                      Prints("设置空闲。\r\n");
 917   5                                              #endif
 918   5                                              //只需要返回一个0长度的数据包即可
 919   5                                              SendLength=0;
 920   5                                              NeedZeroPacket=1;
 921   5                                              //将数据通过EP0返回
 922   5                                              UsbEp0SendData();
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 16  

 923   5                                              break;
 924   5        
 925   5                                      default:
 926   5                                              #ifdef DEBUG0
 927   5                                                      Prints("未知请求。\r\n");
 928   5                                              #endif
 929   5                                      break;
 930   5                                      }
 931   4                                      break;
 932   4          
 933   4                              case 2:  //厂商请求
 934   4                                      #ifdef DEBUG0
 935   4                                              Prints("USB厂商输出请求：\r\n");
 936   4                                      #endif
 937   4                                      break;
 938   4              
 939   4                              default: //未定义的请求。这里只显示一个报错信息。
 940   4                                      #ifdef DEBUG0
 941   4                                              Prints("错误：未定义的输出请求。\r\n");
 942   4                                      #endif
 943   4                                      break;
 944   4                              }
 945   3                      }
 946   2              }
 947   1              //普通数据输出
 948   1              else //if(D12ReadEndpointLastStatus(USB_ENDPOINT0_OUT)&0x20) 之 else
 949   1              {
 950   2                      D12ReadEndpointBuffer(USB_ENDPOINT0_OUT,16,Buffer);
 951   2                      D12ClearBuffer();
 952   2              }
 953   1      }
 954          ////////////////////////End of function//////////////////////////////
 955          
 956          /********************************************************************
 957          函数功能：端点0输入中断处理函数。
 958          入口参数：无。
 959          返    回：无。
 960          备    注：无。
 961          ********************************************************************/
 962          void UsbEp0In(void)
 963          {
 964   1              #ifdef DEBUG0
 965   1                      Prints("USB端点0输入中断。\r\n");
 966   1              #endif
 967   1              
 968   1              //读最后发送状态，这将清除端点0的中断标志位
 969   1              D12ReadEndpointLastStatus(USB_ENDPOINT0_IN);
 970   1              
 971   1              //发送剩余的字节数
 972   1              UsbEp0SendData();
 973   1      }
 974          ////////////////////////End of function//////////////////////////////
 975          
 976          /********************************************************************
 977          函数功能：端点1输出中断处理函数。
 978          入口参数：无。
 979          返    回：无。
 980          备    注：无。
 981          ********************************************************************/
 982          void UsbEp1Out(void)
 983          {
 984   1      #ifdef DEBUG0
C51 COMPILER V9.60.0.0   USBCORE                                                           04/26/2022 15:52:46 PAGE 17  

 985   1       Prints("USB端点1输出中断。\r\n");
 986   1      #endif
 987   1      }
 988          ////////////////////////End of function//////////////////////////////
 989          
 990          /********************************************************************
 991          函数功能：端点1输入中断处理函数。
 992          入口参数：无。
 993          返    回：无。
 994          备    注：无。
 995          ********************************************************************/
 996          void UsbEp1In(void)
 997          {
 998   1      #ifdef DEBUG0
 999   1       Prints("USB端点1输入中断。\r\n");
1000   1      #endif
1001   1       //读最后发送状态，这将清除端点1输入的中断标志位
1002   1       D12ReadEndpointLastStatus(USB_ENDPOINT1_IN);
1003   1       //端点1输入处于空闲状态
1004   1       Ep1InIsBusy=0;
1005   1      }
1006          ////////////////////////End of function//////////////////////////////
1007          
1008          /********************************************************************
1009          函数功能：端点2输出中断处理函数。
1010          入口参数：无。
1011          返    回：无。
1012          备    注：无。
1013          ********************************************************************/
1014          void UsbEp2Out(void)
1015          {
1016   1      #ifdef DEBUG0
1017   1       Prints("USB端点2输出中断。\r\n");
1018   1      #endif
1019   1      }
1020          ////////////////////////End of function//////////////////////////////
1021          
1022          /********************************************************************
1023          函数功能：端点2输入中断处理函数。
1024          入口参数：无。
1025          返    回：无。
1026          备    注：无。
1027          ********************************************************************/
1028          void UsbEp2In(void)
1029          {
1030   1      #ifdef DEBUG0
1031   1       Prints("USB端点2输入中断。\r\n");
1032   1      #endif
1033   1      }
1034          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1238    ----
   CONSTANT SIZE    =    998    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
