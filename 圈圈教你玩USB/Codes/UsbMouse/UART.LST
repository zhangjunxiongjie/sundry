C51 COMPILER V9.60.0.0   UART                                                              04/26/2022 15:52:45 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN UART.OBJ
COMPILER INVOKED BY: D:\Keil-C51\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\keil 5\C51\INC\Atmel) DEBUG O
                    -BJECTEXTEND

line level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3          
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          UART.C  file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.27
  14          修改日期: 2008.07.10
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include <at89x52.H>
  22          
  23          #include "UART.h"
  24          #include "MyType.h"
  25          #include "config.h"
  26          
  27          
  28          volatile uint8 Sending;
  29          
  30          
  31          /********************************************************************
  32          函数功能：串口初始化。
  33          入口参数：无。
  34          返    回：无。
  35          备    注：无。
  36          ********************************************************************/
  37          void InitUART(void)
  38          {
  39   1          EA = 0; //暂时关闭中断
  40   1          TMOD &= 0x0F;       //定时器1模式控制在高4位
  41   1          TMOD |= 0x20;    //定时器1工作在模式2，自动重装模式
  42   1          SCON = 0x50;     //串口工作在模式1
  43   1              // 由串口波特率计算得到 计数值
  44   1              // 乘以 12 是因为 晶振 频率 经过 十二分频 之后 作为 定时器 时钟源
  45   1              // 乘以 16 是因为 串口 数据每一位 需要 采集 十六次。    
  46   1          TH1 = 256-Fclk/(BitRate*12*16);  //计算定时器重装值
  47   1          TL1 = 256-Fclk/(BitRate*12*16);
  48   1          PCON|=0x80;    //串口波特率加倍
  49   1          ES=1;         //串行中断允许
  50   1          TR1=1;        //启动定时器1
  51   1          REN=1;        //允许接收 
  52   1          EA=1;         //允许中断
  53   1      }
  54          ////////////////////////End of function//////////////////////////////
C51 COMPILER V9.60.0.0   UART                                                              04/26/2022 15:52:45 PAGE 2   

  55          
  56          /********************************************************************
  57          函数功能：串口中断处理。
  58          入口参数：无。
  59          返    回：无。
  60          备    注：无。
  61          ********************************************************************/
  62          void UartISR(void) interrupt 4
  63          {
  64   1              if(RI)    //收到数据
  65   1              {
  66   2                      RI=0;   //清中断请求
  67   2              }
  68   1              else      //发送完一字节数据
  69   1              {
  70   2                      TI = 0;
  71   2                      Sending = 0;  //清正在发送标志
  72   2              }
  73   1      }
  74          ////////////////////////End of function//////////////////////////////
  75          
  76          /********************************************************************
  77          函数功能：往串口发送一字节数据。
  78          入口参数：d: 要发送的字节数据。
  79          返    回：无。
  80          备    注：无。
  81          ********************************************************************/
  82          void UartPutChar(uint8 d)
  83          {
  84   1              SBUF=d; //将数据写入到串口缓冲
  85   1              Sending=1;       //设置发送标志
  86   1              while(Sending); //等待发送完毕
  87   1      }
  88          ////////////////////////End of function//////////////////////////////
  89          
  90          /********************************************************************
  91          函数功能：发送一个字符串。
  92          入口参数：pd：要发送的字符串指针。
  93          返    回：无。
  94          备    注：无。
  95          ********************************************************************/
  96          void Prints(uint8 * pd)
  97          {
  98   1              while((*pd)!='\0') //发送字符串，直到遇到0才结束
  99   1              {
 100   2                      UartPutChar(*pd); //发送一个字符
 101   2                      pd++;  //移动到下一个字符
 102   2              }
 103   1      }
 104          ////////////////////////End of function//////////////////////////////
 105          
 106          #ifdef DEBUG1
 107          
 108          /********************************************************************
 109          函数功能：将整数转按十进制字符串发送。
 110          入口参数：x：待显示的整数。
 111          返    回：无。
 112          备    注：无。
 113          ********************************************************************/
 114          void PrintLongInt(uint32 x)
 115          {
 116   1              int8 i;
C51 COMPILER V9.60.0.0   UART                                                              04/26/2022 15:52:45 PAGE 3   

 117   1              uint8 display_buffer[10];
 118   1      
 119   1              for(i=9; i>=0; i--)
 120   1              {
 121   2                      display_buffer[i]='0'+x%10;
 122   2                      x/=10;
 123   2              }
 124   1              for(i=0; i<9; i++)
 125   1              {
 126   2                      if(display_buffer[i]!='0') break;
 127   2              }
 128   1              for(; i<10; i++) UartPutChar(display_buffer[i]);
 129   1      }
 130          ////////////////////////End of function//////////////////////////////
 131          
 132          #endif
 133          
 134          code uint8 HexTable[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
 135          /********************************************************************
 136          函数功能：将短整数按十六进制发送。
 137          入口参数：待发送的整数。
 138          返    回：无。
 139          备    注：无。
 140          ********************************************************************/
 141          void PrintShortIntHex(uint16 x)
 142          {
 143   1              uint8 i;
 144   1              uint8 display_buffer[7];
 145   1              display_buffer[6]=0;
 146   1              display_buffer[0]='0';
 147   1              display_buffer[1]='x';
 148   1              for(i=5; i>=2; i--) //将整数转换为4个字节的HEX值
 149   1              {
 150   2                      display_buffer[i] = HexTable[(x&0xf)];
 151   2                      x >>= 4;
 152   2              }
 153   1              Prints(display_buffer);
 154   1      }
 155          ////////////////////////End of function//////////////////////////////
 156          
 157          #if (defined DEBUG0)||(defined DEBUG1)
 158          /********************************************************************
 159          函数功能：发送一个byte的数据。
 160          入口参数：待发送的数据。
 161          返    回：无。
 162          备    注：无。
 163          ********************************************************************/
 164          void Printc(uint8 x)
 165          {
 166   1              Sending = 1;
 167   1              SBUF = x;
 168   1              while(Sending);
 169   1      }
 170          ////////////////////////End of function//////////////////////////////
 171          
 172          /********************************************************************
 173          函数功能：以HEX格式发送一个byte的数据。
 174          入口参数：待发送的数据
 175          返    回：无。
 176          备    注：无。
 177          ********************************************************************/
 178          void PrintHex(uint8 x)
C51 COMPILER V9.60.0.0   UART                                                              04/26/2022 15:52:45 PAGE 4   

 179          {
 180   1              Printc('0');
 181   1              Printc('x');
 182   1              Printc(HexTable[x>>4]);
 183   1              Printc(HexTable[x&0xf]);
 184   1              Printc(' ');
 185   1      }
 186          ////////////////////////End of function//////////////////////////////
 187          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    333    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
