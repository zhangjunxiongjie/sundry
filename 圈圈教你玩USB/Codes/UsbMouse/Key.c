/******************************************************************
   本程序只供学习使用，未经作者许可，不得用于其它任何用途

        欢迎访问我的USB专区：http://group.ednchina.com/93/
        欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
                             http://computer00.21ic.org

        感谢PCB赞助商――电子园： http://bbs.cepark.com/

KEY.C  file

作者：电脑圈圈
建立日期: 2008.06.27
修改日期: 2008.06.27
版本：V1.2
版权所有，盗版必究。
Copyright(C) 电脑圈圈 2008-2018
All rights reserved            
*******************************************************************/


#include "Key.h"
#include "MyType.h"
#include "config.h"

volatile uint8 idata KeyCurrent,KeyOld,KeyNoChangedTime;
volatile uint8 idata KeyPress;
volatile uint8 idata KeyDown,KeyUp,KeyLast;

volatile uint8 KeyCanChange;

/********************************************************************
函数功能：定时器0初始化，用来做键盘扫描。按键延时消抖
入口参数：无。
返    回：无。
备    注：无。
********************************************************************/
void InitTimer0(void)
{
	TMOD &= 0xF0; // 定时器 0 模式控制在低四位
	TMOD |= 0x01; // 
	ET0 = 1; // 使能 定时计数器 0 溢出中断
	TR0 = 1; // 启动定时计数器
}
/*******************************************************************/


/********************************************************************
函数功能：键盘初始化
入口参数：无。
返    回：无。
备    注：无。
********************************************************************/
void InitKeyboard(void)
{
	KeyIO = 0xFF;	  // 键盘对应的口设置为输入状态
	
	// 消抖延时计数器
	KeyNoChangedTime = 0; // 	
	// 消抖之前 
	KeyCurrent = 0; // 当前端口信号
	KeyOld = 0;		// 上次端口信号
	// 消抖之后
	KeyPress = 0;	// 当前有效按键
	KeyLast = 0; 	// 上次有效按键
	// 
	KeyDown = 0; // 刚按下的按键
	KeyUp = 0;   // 刚释放的按键
	
	// 用于对按键进行周期性扫描
	InitTimer0();		  //初始化定时器
	
	KeyCanChange = 1;	  //允许键值改变
}
/*******************************************************************/

/********************************************************************
函数功能：定时器0中断处理。
入口参数：无。
返    回：无。
备    注：22.1184M晶体约5ms中断一次。
********************************************************************/
void Timer0Isr(void) interrupt 1
{
	//定时器0重装，定时间隔为5ms，加15是为了修正重装所花费时间
	//这个值可以通过软件仿真来确定，在这里设置断点，调整使两次运行
	//时间差刚好为 5ms 即可。定时计数器初值重置，向上计数器
	TH0 = (65536 - (Fclk / 1000 / 12 * 5) + 15) / 256;	 
	TL0 = (65536 - (Fclk / 1000 / 12 * 5) + 15) % 256;   // 

	// 
	if(!KeyCanChange) return;     // 如果正在处理按键，则不再扫描键盘 

	//开始键盘扫描
	//保存按键状态到当前按键情况
	//KeyCurrent总共有8个bit
	//当某个开关按下时，对应的bit为1
	KeyCurrent = GetKeyValue(); //读取键值，GetKeyValue()其实是个宏，不是函数，
						   //这里故意写成函数的样子，美观。它的定义在
						   //key.h文件中
	
	// 这里只要有按键按下就把计时器清零可能导致其它按键动作不能及时采集
	// 当然这里的消抖时间较短问题也不是很大
	if(KeyCurrent != KeyOld)  //如果两次值不等，说明按键情况发生了改变
	{
		KeyNoChangedTime = 0;       //键盘按下时间为0
		KeyOld = KeyCurrent;        //保存当前按键情况
		return;  //返回
	}
	else
	{
		// 当前状态保持计时器
		KeyNoChangedTime++;	     // 按下时间累计 按键延时消抖
		if(KeyNoChangedTime >= 1)	 //如果按下时间足够
		{
			// 保持时间（检测时间）有点短啊。
			KeyNoChangedTime = 1; // 避免没有按键动作时此变量累加导致溢出
			
			KeyPress = KeyOld;      // 保存按键
			
			KeyDown |= (~KeyLast) & (KeyPress); // 求出新按下的键
			KeyUp   |= KeyLast    & (~KeyPress); // 求出新释放的键
			// 用于得到新按下键和新的释放键
			KeyLast = KeyPress;		         // 保存当前按键情况
		}
	}
}
/*******************************************************************/


