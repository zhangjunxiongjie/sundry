C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE PDIUSBD12
OBJECT MODULE PLACED IN PDIUSBD12.OBJ
COMPILER INVOKED BY: D:\Keil-v5-C51\C51\BIN\C51.EXE PDIUSBD12.c OPTIMIZE(8,SPEED) BROWSE INCDIR(D:\Keil-v5-C51\C51\INC\A
                    -tmel) DEBUG OBJECTEXTEND

line level    source

   1          /******************************************************************
   2             本程序只供学习使用，未经作者许可，不得用于其它任何用途
   3          
   4                  欢迎访问我的USB专区：http://group.ednchina.com/93/
   5                  欢迎访问我的blog：   http://www.ednchina.com/blog/computer00
   6                                       http://computer00.21ic.org
   7          
   8                  感谢PCB赞助商――电子园： http://bbs.cepark.com/
   9          
  10          PDIUSBD12.C  file
  11          
  12          作者：电脑圈圈
  13          建立日期: 2008.06.27
  14          修改日期: 2008.08.05
  15          版本：V1.1
  16          版权所有，盗版必究。
  17          Copyright(C) 电脑圈圈 2008-2018
  18          All rights reserved            
  19          *******************************************************************/
  20          
  21          #include <AT89x52.H>
  22          #include "MyType.h"
  23          #include "PDIUSBD12.H"
  24          #include "config.h"
  25          #include "UART.h"
  26          
  27          /********************************************************************
  28          函数功能：D12写命令。
  29          入口参数：Command：一字节命令。
  30          返    回：无。
  31          备    注：无。
  32          ********************************************************************/
  33          void D12WriteCommand(uint8 Command)
  34          {
  35   1              D12SetCommandAddr();  //设置为命令地址
  36   1              D12ClrWr(); //WR置低
  37   1              D12SetPortOut(); //将数据口设置为输出状态（注意这里为空宏，移植时可能有用）
  38   1              D12SetData(Command);  //输出命令到数据口上
  39   1              D12SetWr(); //WR置高
  40   1              D12SetPortIn(); //将数据口设置为输入状态，以备后面输入使用
  41   1      }
  42          ////////////////////////End of function//////////////////////////////
  43          
  44          /********************************************************************
  45          函数功能：读一字节D12数据。
  46          入口参数：无。
  47          返    回：读回的一字节。
  48          备    注：无。
  49          ********************************************************************/
  50          uint8 D12ReadByte(void)
  51          {
  52   1              uint8 temp;
  53   1              D12SetDataAddr(); //设置为数据地址
  54   1              D12ClrRd(); //RD置低
C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 2   

  55   1              temp=D12GetData(); //读回数据
  56   1              D12SetRd(); //RD置高
  57   1              return temp; //返回读到数据
  58   1      }
  59          ////////////////////////End of function//////////////////////////////
  60          
  61          /********************************************************************
  62          函数功能：读D12的ID。
  63          入口参数：无。
  64          返    回：D12的ID。
  65          备    注：无。
  66          ********************************************************************/
  67          uint16 D12ReadID(void)
  68          {
  69   1              uint16 id;
  70   1              D12WriteCommand(Read_ID); //写读 ID 命令
  71   1              id = D12ReadByte(); //读回 ID 号低字节
  72   1              id |= ((uint16)D12ReadByte())<<8; //读回 ID 号高字节
  73   1              
  74   1              return id;
  75   1      }
  76          ////////////////////////End of function//////////////////////////////
  77          
  78          /********************************************************************
  79          函数功能：写一字节D12数据。
  80          入口参数：Value：要写的一字节数据。
  81          返    回：无。
  82          备    注：无。
  83          ********************************************************************/
  84          void D12WriteByte(uint8 Value)
  85          {
  86   1              D12SetDataAddr(); //设置为数据地址
  87   1              D12ClrWr(); //WR置低
  88   1              D12SetPortOut(); //将数据口设置为输出状态（注意这里为空宏，移植时可能有用）
  89   1              D12SetData(Value); //写出数据
  90   1              D12SetWr(); //WR置高
  91   1              D12SetPortIn(); //将数据口设置为输入状态，以备后面输入使用
  92   1      }
  93          ////////////////////////End of function//////////////////////////////
  94          
  95          /********************************************************************
  96          函数功能：读取D12最后传输状态寄存器的函数。
  97          入口参数：Endp：端点号。
  98          返    回：端点的最后传输状态。
  99          备    注：该操作将清除该端点的中断标志位。
 100          ********************************************************************/
 101          uint8 D12ReadEndpointLastStatus(uint8 Endp)
 102          {
 103   1              D12WriteCommand(0x40+Endp); //读取端点最后状态的命令
 104   1              return D12ReadByte();
 105   1      }
 106          ////////////////////////End of function//////////////////////////////
 107          
 108          /********************************************************************
 109          函数功能：选择端点的函数，选择一个端点后才能对它进行数据操作。
 110          入口参数：Endp：端点号。
 111          返    回：无。
 112          备    注：无。
 113          ********************************************************************/
 114          void D12SelectEndpoint(uint8 Endp)
 115          {
 116   1              D12WriteCommand(0x00+Endp); //选择端点的命令
C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 3   

 117   1      }
 118          ////////////////////////End of function//////////////////////////////
 119          
 120          /********************************************************************
 121          函数功能：清除接收端点缓冲区的函数。
 122          入口参数：无。
 123          返    回：无。
 124          备    注：只有使用该函数清除端点缓冲后，该接收端点才能接收新的数据包。
 125          ********************************************************************/
 126          void D12ClearBuffer(void)
 127          {
 128   1       D12WriteCommand(D12_CLEAR_BUFFER);
 129   1      }
 130          ////////////////////////End of function//////////////////////////////
 131          
 132          /********************************************************************
 133          函数功能：应答建立包的函数。
 134          入口参数：无。
 135          返    回：无。
 136          备    注：无。
 137          ********************************************************************/
 138          void D12AcknowledgeSetup(void)
 139          {
 140   1       D12SelectEndpoint(1); //选择端点0输入
 141   1       D12WriteCommand(D12_ACKNOWLEDGE_SETUP); //发送应答设置到端点0输入
 142   1       D12SelectEndpoint(0); //选择端点0输出
 143   1       D12WriteCommand(D12_ACKNOWLEDGE_SETUP); //发送应答设置到端点0输出
 144   1      }
 145          ////////////////////////End of function//////////////////////////////
 146          
 147          /********************************************************************
 148          函数功能：读取端点缓冲区函数。
 149          入口参数：Endp：端点号；Len：需要读取的长度；Buf：保存数据的缓冲区。
 150          返    回：实际读到的数据长度。
 151          备    注：无。
 152          ********************************************************************/
 153          uint8 D12ReadEndpointBuffer(uint8 Endp, uint8 Len, uint8 *Buf)
 154          {
 155   1       uint8 i,j;
 156   1       D12SelectEndpoint(Endp); //选择要操作的端点缓冲
 157   1       D12WriteCommand(D12_READ_BUFFER); //发送读缓冲区的命令
 158   1       D12ReadByte();   //该字节数据是保留的，不用。
 159   1       j=D12ReadByte(); //这里才是实际的接收到的数据长度
 160   1       if(j>Len) //如果要读的字节数比实际接收到的数据长
 161   1       {
 162   2        j=Len;  //则只读指定的长度数据
 163   2       }
 164   1      #ifdef DEBUG1 //如果定义了DEBUG1，则需要显示调试信息
               Prints("读端点");
               PrintLongInt(Endp/2); //端点号。由于D12特殊的端点组织形式，
                                     //这里的0和1分别表示端点0的输出和输入；
                                     //而2、3分别表示端点1的输出和输入；
                                     //3、4分别表示端点2的输出和输入。
                                     //因此要除以2才显示对应的端点。
               Prints("缓冲区");
               PrintLongInt(j);      //实际读取的字节数
               Prints("字节。\r\n");
              #endif
 175   1       for(i=0;i<j;i++)
 176   1       {
 177   2        //这里不直接调用读一字节的函数，而直接在这里模拟时序，可以节省时间
 178   2        D12ClrRd();  //RD置低
C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 4   

 179   2        *(Buf+i)=D12GetData(); //读一字节数据
 180   2        D12SetRd();  //RD置高
 181   2      #ifdef DEBUG1
                PrintHex(*(Buf+i)); //如果需要显示调试信息，则显示读到的数据
                if(((i+1)%16)==0)Prints("\r\n"); //每16字节换行一次
              #endif
 185   2       }
 186   1      #ifdef DEBUG1
               if((j%16)!=0)Prints("\r\n"); //换行。
              #endif
 189   1       return j; //返回实际读取的字节数。
 190   1      }
 191          ////////////////////////End of function//////////////////////////////
 192          
 193          /********************************************************************
 194          函数功能：使能发送端点缓冲区数据有效的函数。
 195          入口参数：无。
 196          返    回：无。
 197          备    注：只有使用该函数使能发送端点数据有效之后，数据才能发送出去。
 198          ********************************************************************/
 199          void D12ValidateBuffer(void)
 200          {
 201   1       D12WriteCommand(D12_VALIDATE_BUFFER);
 202   1      }
 203          ////////////////////////End of function//////////////////////////////
 204          
 205          /********************************************************************
 206          函数功能：将数据写入端点缓冲区函数。
 207          入口参数：Endp：端点号；Len：需要发送的长度；Buf：保存数据的缓冲区。
 208          返    回：Len的值。
 209          备    注：无。
 210          ********************************************************************/
 211          uint8 D12WriteEndpointBuffer(uint8 Endp,uint8 Len,uint8 * Buf)
 212          {
 213   1       uint8 i;
 214   1       D12SelectEndpoint(Endp); //选择端点
 215   1       D12WriteCommand(D12_WRITE_BUFFER); //写Write Buffer命令
 216   1       D12WriteByte(0); //该字节必须写0
 217   1       D12WriteByte(Len);  //写需要发送数据的长度
 218   1       
 219   1      #ifdef DEBUG1 //如果定义了DEBUG1，则需要显示调试信息
               Prints("写端点");
               PrintLongInt(Endp/2); //端点号。由于D12特殊的端点组织形式，
                                     //这里的0和1分别表示端点0的输出和输入；
                                     //而2、3分别表示端点1的输出和输入；
                                     //3、4分别表示端点2的输出和输入。
                                     //因此要除以2才显示对应的端点。
               Prints("缓冲区");
               PrintLongInt(Len);    //写入的字节数
               Prints("字节。\r\n");
              #endif
 230   1       D12SetPortOut(); //将数据口设置为输出状态（注意这里为空宏，移植时可能有用）
 231   1       for(i=0;i<Len;i++)
 232   1       {
 233   2        //这里不直接调用写一字节的函数，而直接在这里模拟时序，可以节省时间
 234   2        D12ClrWr(); //WR置低  
 235   2        D12SetData(*(Buf+i)); //将数据放到数据线上
 236   2        D12SetWr();  //WR置高，完成一字节写
 237   2      #ifdef DEBUG1
                PrintHex(*(Buf+i));  //如果需要显示调试信息，则显示发送的数据
                if(((i+1)%16)==0)Prints("\r\n"); //每16字节换行一次
              #endif
C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 5   

 241   2        }
 242   1      #ifdef DEBUG1
               if((Len%16)!=0)Prints("\r\n"); //换行
              #endif
 245   1       D12SetPortIn(); //数据口切换到输入状态
 246   1       D12ValidateBuffer(); //使端点数据有效
 247   1       return Len; //返回Len
 248   1      }
 249          ////////////////////////End of function//////////////////////////////
 250          
 251          /********************************************************************
 252          函数功能：设置地址函数。
 253          入口参数：Addr：要设置的地址值。
 254          返    回：无。
 255          备    注：无。
 256          ********************************************************************/
 257          void D12SetAddress(uint8 Addr)
 258          {
 259   1       D12WriteCommand(D12_SET_ADDRESS_ENABLE); //写设置地址命令
 260   1       D12WriteByte(0x80 | Addr); //写一字节数据：使能及地址
 261   1      }
 262          ////////////////////////End of function//////////////////////////////
 263          
 264          /********************************************************************
 265          函数功能：使能端点函数。
 266          入口参数：Enable: 是否使能。0值为不使能，非0值为使能。
 267          返    回：无。
 268          备    注：无。
 269          ********************************************************************/
 270          void D12SetEndpointEnable(uint8 Enable)
 271          {
 272   1       D12WriteCommand(D12_SET_ENDPOINT_ENABLE);
 273   1       if(Enable!=0)
 274   1       {
 275   2        D12WriteByte(0x01); //D0为1使能端点
 276   2       }
 277   1       else
 278   1       {
 279   2        D12WriteByte(0x00); //不使能端点
 280   2       }
 281   1      }
 282          ////////////////////////End of function//////////////////////////////
 283          
 284          /********************************************************************
 285          函数功能：读取D12端点状态函数。
 286          入口参数：Endp：端点号。
 287          返    回：端点状态寄存器的值。
 288          备    注：无。
 289          ********************************************************************/
 290          uint8 D12ReadEndpointStatus(uint8 Endp)
 291          {
 292   1       D12WriteCommand(0x80+Endp); //读取端点状态命令
 293   1       return D12ReadByte();
 294   1      }
 295          ////////////////////////End of function//////////////////////////////


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    262    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.57.0.0   PDIUSBD12                                                         08/23/2021 14:18:43 PAGE 6   

   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
