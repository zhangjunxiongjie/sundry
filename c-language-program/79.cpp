//贪心算法 求走过每个（所有）城市的最短路径 
#include <stdio.h>
#define n 4     //定义一个常量 
int main ()
{
int S[n],D[n][n],sum,I,j,K,L,Dtemp,Found;
S[0]=0;sum=0;   //sum储存总的路径和，S【】记录走过的城市，起始城市是0城 
           D[0][1]=2; D[0][2]=6; D[0][3]=5;    //给出任意两个城市的距离 
D[1][0]=2;            D[1][2]=4; D[1][3]=4;   //每个城市都用数字表示 
D[2][0]=6; D[2][1]=4;            D[2][3]=2; 
D[3][0]=5; D[3][1]=4; D[3][2]=2;
I=1;
do
  {
  	K=1;Dtemp=10000;   //K代表城市， Dtemp储存当前城市到下一最短路径城市的路径 
  	do
	  {
	  	L=0;Found=0;   //L作为遍历所有城市的一个中间变量 
	  	do
		  {
		  	if(S[L]==K)
		  	  {
		  	  	Found=1;   // 储存当前K值所指城市是否为已经经过的城市 
		  	  	break;     
			  }
			else L=L+1;
		  }while(L<I);    //要求K不是S【】中储存的已经经过的城市，需要遍历一下S【】中储存的所有城市 
		if(Found==0&&D[K][S[I-1]]<Dtemp)   //当不是已经经过的城市且为未经过城市当中路径最小值时将其路径放在Dtemp中 
		  {                                //此条件语句可以在不是已经经过的城市时选出其中路径最小的那个 
		  	j=K;   //把当前最符合条件的城市临时放在j中       
		  	Dtemp=D[K][S[I-1]];
	      }
	    K=K+1;
	  }while(K<n);  //第一层循环是遍历已经经过的城市判断当前城市是否为已经经过的城市，第二层循环遍历当前所有未经过城市选出其中路径最小的城市 
	S[I]=j;I=I+1;sum=sum+Dtemp;  //把此城市放在已经经过城市中，并计入总路程 
}while(I<n);      //当到达最后一个城市时结束 
printf("%d,%d,%d\n",sum,j,D[4][3]); 
sum=sum+D[I][j];      //D【I】【j】是与最后一个城市的距离 
for(j=0;j<n;j++)
{
  printf("%d,",S[j]);
}
printf("\n");
printf("Total Length:%d\n",sum);
}



